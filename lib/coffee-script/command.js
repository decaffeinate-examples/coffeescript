var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/* eslint-disable
    consistent-return,
    func-names,
    global-require,
    max-len,
    no-bitwise,
    no-cond-assign,
    no-console,
    no-multi-assign,
    no-param-reassign,
    no-restricted-syntax,
    no-return-assign,
    no-shadow,
    no-unused-vars,
    no-use-before-define,
    no-var,
    vars-on-top,
*/
// TODO: This file was created by bulk-decaffeinate.
// Fix any style issues and re-enable lint.
/*
 * decaffeinate suggestions:
 * DS101: Remove unnecessary use of Array.from
 * DS102: Remove unnecessary code created because of implicit returns
 * DS205: Consider reworking code to avoid use of IIFEs
 * DS207: Consider shorter variations of null checks
 * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md
 */
// The `coffee` utility. Handles command-line compilation of CoffeeScript
// into various forms: saved into `.js` files or printed to stdout
// or recompiled every time the source is saved,
// printed as a token stream or as the syntax tree, or launch an
// interactive REPL.

// External dependencies.
var fs = require('fs');
var path = require('path');

var _require = require('child_process'),
    spawn = _require.spawn,
    exec = _require.exec;

var _require2 = require('events'),
    EventEmitter = _require2.EventEmitter;

var helpers = require('./helpers');
var optparse = require('./optparse');
var CoffeeScript = require('./coffee-script');

var useWinPathSep = path.sep === '\\';

// Allow CoffeeScript to emit Node.js events.
helpers.extend(CoffeeScript, new EventEmitter());

var printLine = function printLine(line) {
  return process.stdout.write(line + '\n');
};
var printWarn = function printWarn(line) {
  return process.stderr.write(line + '\n');
};

var hidden = function hidden(file) {
  return (/^\.|~$/.test(file)
  );
};

// The help banner that is printed in conjunction with `-h`/`--help`.
var BANNER = 'Usage: coffee [options] path/to/script.coffee -- [args]\n\nIf called without options, `coffee` will run your script.';

// The list of all the valid option flags that `coffee` knows how to handle.
var SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive CoffeeScript REPL'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-m', '--map', 'generate source map and save as .js.map files'], ['-M', '--inline-map', 'generate source map and include it directly in output'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['--nodejs [ARGS]', 'pass options directly to the "node" binary'], ['--no-header', 'suppress the "Generated by" header'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-r', '--require [MODULE*]', 'require the given module before eval or REPL'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-l', '--literate', 'treat stdio as literate style coffee-script'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands']];

// Top-level objects shared by all the functions.
var opts = {};
var sources = [];
var sourceCode = [];
var notSources = {};
var watchedDirs = {};
var optionParser = null;

// Run `coffee` by parsing passed options and determining what action to take.
// Many flags cause us to divert before compiling anything. Flags passed after
// `--` will be passed verbatim to your script as arguments in `process.argv`
exports.run = function () {
  parseOptions();
  // Make the REPL *CLI* use the global context so as to (a) be consistent with the
  // `node` REPL CLI and, therefore, (b) make packages that modify native prototypes
  // (such as 'colors' and 'sugar') work as expected.
  var replCliOpts = { useGlobal: true };
  if (opts.require) {
    opts.prelude = makePrelude(opts.require);
  }
  replCliOpts.prelude = opts.prelude;
  if (opts.nodejs) {
    return forkNode();
  }
  if (opts.help) {
    return usage();
  }
  if (opts.version) {
    return version();
  }
  if (opts.interactive) {
    return require('./repl').start(replCliOpts);
  }
  if (opts.stdio) {
    return compileStdio();
  }
  if (opts.eval) {
    return compileScript(null, opts.arguments[0]);
  }
  if (!opts.arguments.length) {
    return require('./repl').start(replCliOpts);
  }
  var literals = opts.run ? opts.arguments.splice(1) : [];
  process.argv = process.argv.slice(0, 2).concat(literals);
  process.argv[0] = 'coffee';

  if (opts.output) {
    opts.output = path.resolve(opts.output);
  }
  if (opts.join) {
    opts.join = path.resolve(opts.join);
    console.error('\nThe --join option is deprecated and will be removed in a future version.\n\nIf for some reason it\'s necessary to share local variables between files,\nreplace...\n\n    $ coffee --compile --join bundle.js -- a.coffee b.coffee c.coffee\n\nwith...\n\n    $ cat a.coffee b.coffee c.coffee | coffee --compile --stdio > bundle.js\n');
  }
  return function () {
    var result = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Array.from(opts.arguments)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var source = _step.value;

        source = path.resolve(source);
        result.push(compilePath(source, true, source));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return result;
  }();
};

var makePrelude = function makePrelude(requires) {
  return requires.map(function (module) {
    var match = void 0;var name = void 0;
    if (match = module.match(/^(.*)=(.*)$/)) {
      var _ = void 0;

      var _Array$from = Array.from(match);

      var _Array$from2 = _slicedToArray(_Array$from, 3);

      _ = _Array$from2[0];
      name = _Array$from2[1];
      module = _Array$from2[2];
    }
    if (!name) {
      name = helpers.baseFileName(module, true, useWinPathSep);
    }
    return name + ' = require(\'' + module + '\')';
  }).join(';');
};

// Compile a path, which could be a script or a directory. If a directory
// is passed, recursively compile all '.coffee', '.litcoffee', and '.coffee.md'
// extension source files in it and all subdirectories.
var compilePath = function compilePath(source, topLevel, base) {
  var err = void 0;var stats = void 0;
  if (Array.from(sources).includes(source) || watchedDirs[source] || !topLevel && (notSources[source] || hidden(source))) {
    return;
  }
  try {
    stats = fs.statSync(source);
  } catch (error) {
    err = error;
    if (err.code === 'ENOENT') {
      console.error('File not found: ' + source);
      process.exit(1);
    }
    throw err;
  }
  if (stats.isDirectory()) {
    var files = void 0;
    if (path.basename(source) === 'node_modules') {
      notSources[source] = true;
      return;
    }
    if (opts.run) {
      compilePath(findDirectoryIndex(source), topLevel, base);
      return;
    }
    if (opts.watch) {
      watchDir(source, base);
    }
    try {
      files = fs.readdirSync(source);
    } catch (error1) {
      err = error1;
      if (err.code === 'ENOENT') {
        return;
      }throw err;
    }
    return Array.from(files).map(function (file) {
      return compilePath(path.join(source, file), false, base);
    });
  }if (topLevel || helpers.isCoffee(source)) {
    var code = void 0;
    sources.push(source);
    sourceCode.push(null);
    delete notSources[source];
    if (opts.watch) {
      watch(source, base);
    }
    try {
      code = fs.readFileSync(source);
    } catch (error2) {
      err = error2;
      if (err.code === 'ENOENT') {
        return;
      }throw err;
    }
    return compileScript(source, code.toString(), base);
  }
  return notSources[source] = true;
};

var findDirectoryIndex = function findDirectoryIndex(source) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = Array.from(CoffeeScript.FILE_EXTENSIONS)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var ext = _step2.value;

      var index = path.join(source, 'index' + ext);
      try {
        if (fs.statSync(index).isFile()) {
          return index;
        }
      } catch (err) {
        if (err.code !== 'ENOENT') {
          throw err;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  console.error('Missing index.coffee or index.litcoffee in ' + source);
  return process.exit(1);
};

// Compile a single source script, containing the given code, according to the
// requested options. If evaluating the script directly sets `__filename`,
// `__dirname` and `module.filename` to be correct relative to the script's path.
var compileScript = function compileScript(file, input) {
  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var task = void 0;
  var o = opts;
  var options = compileOptions(file, base);
  try {
    var t = task = { file: file, input: input, options: options };
    CoffeeScript.emit('compile', task);
    if (o.tokens) {
      return printTokens(CoffeeScript.tokens(t.input, t.options));
    }if (o.nodes) {
      return printLine(CoffeeScript.nodes(t.input, t.options).toString().trim());
    }if (o.run) {
      CoffeeScript.register();
      if (opts.prelude) {
        CoffeeScript.eval(opts.prelude, t.options);
      }
      return CoffeeScript.run(t.input, t.options);
    }if (o.join && t.file !== o.join) {
      if (helpers.isLiterate(file)) {
        t.input = helpers.invertLiterate(t.input);
      }
      sourceCode[sources.indexOf(t.file)] = t.input;
      return compileJoin();
    }
    var compiled = CoffeeScript.compile(t.input, t.options);
    t.output = compiled;
    if (o.map) {
      t.output = compiled.js;
      t.sourceMap = compiled.v3SourceMap;
    }

    CoffeeScript.emit('success', task);
    if (o.print) {
      return printLine(t.output.trim());
    }if (o.compile || o.map) {
      return writeJs(base, t.file, t.output, options.jsPath, t.sourceMap);
    }
  } catch (err) {
    CoffeeScript.emit('failure', err, task);
    if (CoffeeScript.listeners('failure').length) {
      return;
    }
    var message = (err != null ? err.stack : undefined) || '' + err;
    if (o.watch) {
      return printLine(message + '\x07');
    }
    printWarn(message);
    return process.exit(1);
  }
};

// Attach the appropriate listeners to compile scripts incoming over **stdin**,
// and write them back to **stdout**.
var compileStdio = function compileStdio() {
  var buffers = [];
  var stdin = process.openStdin();
  stdin.on('data', function (buffer) {
    if (buffer) {
      return buffers.push(buffer);
    }
  });
  return stdin.on('end', function () {
    return compileScript(null, Buffer.concat(buffers).toString());
  });
};

// If all of the source files are done being read, concatenate and compile
// them together.
var joinTimeout = null;
var compileJoin = function compileJoin() {
  if (!opts.join) {
    return;
  }
  if (!sourceCode.some(function (code) {
    return code === null;
  })) {
    clearTimeout(joinTimeout);
    return joinTimeout = wait(100, function () {
      return compileScript(opts.join, sourceCode.join('\n'), opts.join);
    });
  }
};

// Watch a source CoffeeScript file using `fs.watch`, recompiling it every
// time the file is updated. May be used in combination with other options,
// such as `--print`.
var watch = function watch(source, base) {
  var watcher = null;
  var prevStats = null;
  var compileTimeout = null;

  var watchErr = function watchErr(err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
    if (!Array.from(sources).includes(source)) {
      return;
    }
    try {
      rewatch();
      return compile();
    } catch (error1) {
      removeSource(source, base);
      return compileJoin();
    }
  };

  var compile = function compile() {
    clearTimeout(compileTimeout);
    return compileTimeout = wait(25, function () {
      return fs.stat(source, function (err, stats) {
        if (err) {
          return watchErr(err);
        }
        if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
          return rewatch();
        }
        prevStats = stats;
        return fs.readFile(source, function (err, code) {
          if (err) {
            return watchErr(err);
          }
          compileScript(source, code.toString(), base);
          return rewatch();
        });
      });
    });
  };

  var startWatcher = function startWatcher() {
    return watcher = fs.watch(source).on('change', compile).on('error', function (err) {
      if (err.code !== 'EPERM') {
        throw err;
      }
      return removeSource(source, base);
    });
  };

  var rewatch = function rewatch() {
    if (watcher != null) {
      watcher.close();
    }
    return startWatcher();
  };

  try {
    return startWatcher();
  } catch (error) {
    var err = error;
    return watchErr(err);
  }
};

// Watch a directory of files for new additions.
var watchDir = function watchDir(source, base) {
  var watcher = null;
  var readdirTimeout = null;

  var startWatcher = function startWatcher() {
    return watcher = fs.watch(source).on('error', function (err) {
      if (err.code !== 'EPERM') {
        throw err;
      }
      return stopWatcher();
    }).on('change', function () {
      clearTimeout(readdirTimeout);
      return readdirTimeout = wait(25, function () {
        var files = void 0;
        try {
          files = fs.readdirSync(source);
        } catch (err) {
          if (err.code !== 'ENOENT') {
            throw err;
          }
          return stopWatcher();
        }
        return Array.from(files).map(function (file) {
          return compilePath(path.join(source, file), false, base);
        });
      });
    });
  };

  var stopWatcher = function stopWatcher() {
    watcher.close();
    return removeSourceDir(source, base);
  };

  watchedDirs[source] = true;
  try {
    return startWatcher();
  } catch (error) {
    var err = error;
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }
};

var removeSourceDir = function removeSourceDir(source, base) {
  delete watchedDirs[source];
  var sourcesChanged = false;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = Array.from(sources)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var file = _step3.value;

      if (source === path.dirname(file)) {
        removeSource(file, base);
        sourcesChanged = true;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (sourcesChanged) {
    return compileJoin();
  }
};

// Remove a file from our source list, and source code cache. Optionally remove
// the compiled JS version as well.
var removeSource = function removeSource(source, base) {
  var index = sources.indexOf(source);
  sources.splice(index, 1);
  sourceCode.splice(index, 1);
  if (!opts.join) {
    silentUnlink(outputPath(source, base));
    silentUnlink(outputPath(source, base, '.js.map'));
    return timeLog('removed ' + source);
  }
};

var silentUnlink = function silentUnlink(path) {
  try {
    return fs.unlinkSync(path);
  } catch (err) {
    if (!['ENOENT', 'EPERM'].includes(err.code)) {
      throw err;
    }
  }
};

// Get the corresponding output JavaScript path for a source file.
var outputPath = function outputPath(source, base, extension) {
  var dir = void 0;
  if (extension == null) {
    extension = '.js';
  }
  var basename = helpers.baseFileName(source, true, useWinPathSep);
  var srcDir = path.dirname(source);
  if (!opts.output) {
    dir = srcDir;
  } else if (source === base) {
    dir = opts.output;
  } else {
    dir = path.join(opts.output, path.relative(base, srcDir));
  }
  return path.join(dir, basename + extension);
};

// Recursively mkdir, like `mkdir -p`.
var mkdirp = function mkdirp(dir, fn) {
  var _mkdirs = void 0;
  var mode = 511 & ~process.umask();

  return (_mkdirs = function mkdirs(p, fn) {
    return fs.exists(p, function (exists) {
      if (exists) {
        return fn();
      }
      return _mkdirs(path.dirname(p), function () {
        return fs.mkdir(p, mode, function (err) {
          if (err) {
            return fn(err);
          }
          return fn();
        });
      });
    });
  })(dir, fn);
};

// Write out a JavaScript source file with the compiled code. By default, files
// are written out in `cwd` as `.js` files with the same name, but the output
// directory can be customized with `--output`.
//
// If `generatedSourceMap` is provided, this will write a `.js.map` file into the
// same directory as the `.js` file.
var writeJs = function writeJs(base, sourcePath, js, jsPath) {
  var generatedSourceMap = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  var sourceMapPath = outputPath(sourcePath, base, '.js.map');
  var jsDir = path.dirname(jsPath);
  var compile = function compile() {
    if (opts.compile) {
      if (js.length <= 0) {
        js = ' ';
      }
      if (generatedSourceMap) {
        js = js + '\n//# sourceMappingURL=' + helpers.baseFileName(sourceMapPath, false, useWinPathSep) + '\n';
      }
      fs.writeFile(jsPath, js, function (err) {
        if (err) {
          printLine(err.message);
          return process.exit(1);
        }if (opts.compile && opts.watch) {
          return timeLog('compiled ' + sourcePath);
        }
      });
    }
    if (generatedSourceMap) {
      return fs.writeFile(sourceMapPath, generatedSourceMap, function (err) {
        if (err) {
          printLine('Could not write source map: ' + err.message);
          return process.exit(1);
        }
      });
    }
  };
  return fs.exists(jsDir, function (itExists) {
    if (itExists) {
      return compile();
    }return mkdirp(jsDir, compile);
  });
};

// Convenience for cleaner setTimeouts.
var wait = function wait(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

// When watching scripts, it's useful to log changes with the timestamp.
var timeLog = function timeLog(message) {
  return console.log(new Date().toLocaleTimeString() + ' - ' + message);
};

// Pretty-print a stream of tokens, sans location data.
var printTokens = function printTokens(tokens) {
  var strings = function () {
    var result = [];
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = Array.from(tokens)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var token = _step4.value;

        var tag = token[0];
        var value = token[1].toString().replace(/\n/, '\\n');
        result.push('[' + tag + ' ' + value + ']');
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    return result;
  }();
  return printLine(strings.join(' '));
};

// Use the [OptionParser module](optparse.html) to extract all options from
// `process.argv` that are specified in `SWITCHES`.
var parseOptions = function parseOptions() {
  optionParser = new optparse.OptionParser(SWITCHES, BANNER);
  var o = opts = optionParser.parse(process.argv.slice(2));
  if (!o.compile) {
    o.compile = !!o.output;
  }
  o.run = !(o.compile || o.print || o.map);
  return o.print = !!(o.print || o.eval || o.stdio && o.compile);
};

// The compile-time options to pass to the CoffeeScript compiler.
var compileOptions = function compileOptions(filename, base) {
  var answer = {
    filename: filename,
    literate: opts.literate || helpers.isLiterate(filename),
    bare: opts.bare,
    header: opts.compile && !opts['no-header'],
    sourceMap: opts.map,
    inlineMap: opts['inline-map']
  };
  if (filename) {
    if (base) {
      var cwd = process.cwd();
      var jsPath = outputPath(filename, base);
      var jsDir = path.dirname(jsPath);
      answer = helpers.merge(answer, {
        jsPath: jsPath,
        sourceRoot: path.relative(jsDir, cwd),
        sourceFiles: [path.relative(cwd, filename)],
        generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep)
      });
    } else {
      answer = helpers.merge(answer, {
        sourceRoot: '',
        sourceFiles: [helpers.baseFileName(filename, false, useWinPathSep)],
        generatedFile: helpers.baseFileName(filename, true, useWinPathSep) + '.js'
      });
    }
  }
  return answer;
};

// Start up a new Node.js instance with the arguments in `--nodejs` passed to
// the `node` binary, preserving the other options.
var forkNode = function forkNode() {
  var nodeArgs = opts.nodejs.split(/\s+/);
  var args = process.argv.slice(1);
  args.splice(args.indexOf('--nodejs'), 2);
  var p = spawn(process.execPath, nodeArgs.concat(args), {
    cwd: process.cwd(),
    env: process.env,
    stdio: [0, 1, 2]
  });
  return p.on('exit', function (code) {
    return process.exit(code);
  });
};

// Print the `--help` usage message and exit. Deprecated switches are not
// shown.
var usage = function usage() {
  return printLine(new optparse.OptionParser(SWITCHES, BANNER).help());
};

// Print the `--version` message and exit.
var version = function version() {
  return printLine('CoffeeScript version ' + CoffeeScript.VERSION);
};